import{ax as T,ay as R,az as m,r as O,S as q,A as B,aA as U,V as S,p as V,U as F,aB as j,h as x,aC as z,aD as H,m as L,aE as h,aF as M,i as N,aG as I}from"./B0J0WvHt.js";function K(e){return Array.isArray(e)?e:[e]}const G=e=>e==="defer"||e===!1;function k(...e){var b;const r=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&e.unshift(r);let[s,i,t={}]=e;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const a=R(),l=i,p=()=>m.value,P=()=>a.isHydrating?a.payload.data[s]:a.static.data[s];t.server=t.server??!0,t.default=t.default??p,t.getCachedData=t.getCachedData??P,t.lazy=t.lazy??!1,t.immediate=t.immediate??!0,t.deep=t.deep??m.deep,t.dedupe=t.dedupe??"cancel";const y=t.getCachedData(s,a),_=y!=null;if(!a._asyncData[s]||!t.immediate){(b=a.payload._errors)[s]??(b[s]=m.errorValue);const c=t.deep?O:q;a._asyncData[s]={data:c(_?y:t.default()),pending:O(!_),error:B(a.payload._errors,s),status:O("idle"),_default:t.default}}const n={...a._asyncData[s]};delete n._default,n.refresh=n.execute=(c={})=>{if(a._asyncDataPromises[s]){if(G(c.dedupe??t.dedupe))return a._asyncDataPromises[s];a._asyncDataPromises[s].cancelled=!0}if(c._initial||a.isHydrating&&c._initial!==!1){const u=c._initial?y:t.getCachedData(s,a);if(u!=null)return Promise.resolve(u)}n.pending.value=!0,n.status.value="pending";const f=new Promise((u,o)=>{try{u(l(a))}catch(D){o(D)}}).then(async u=>{if(f.cancelled)return a._asyncDataPromises[s];let o=u;t.transform&&(o=await t.transform(u)),t.pick&&(o=Q(o,t.pick)),a.payload.data[s]=o,n.data.value=o,n.error.value=m.errorValue,n.status.value="success"}).catch(u=>{if(f.cancelled)return a._asyncDataPromises[s];n.error.value=j(u),n.data.value=x(t.default()),n.status.value="error"}).finally(()=>{f.cancelled||(n.pending.value=!1,delete a._asyncDataPromises[s])});return a._asyncDataPromises[s]=f,a._asyncDataPromises[s]},n.clear=()=>J(a,s);const v=()=>n.refresh({_initial:!0}),g=t.server!==!1&&a.payload.serverRendered;{const c=z();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const o=c._nuxtOnBeforeMountCbs;U(()=>{o.forEach(D=>{D()}),o.splice(0,o.length)}),S(()=>o.splice(0,o.length))}g&&a.isHydrating&&(n.error.value||y!=null)?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):c&&(a.payload.serverRendered&&a.isHydrating||t.lazy)&&t.immediate?c._nuxtOnBeforeMountCbs.push(v):t.immediate&&v();const f=H();if(t.watch){const o=V(t.watch,()=>n.refresh());f&&F(o)}const u=a.hook("app:data:refresh",async o=>{(!o||o.includes(s))&&await n.refresh()});f&&F(u)}const w=Promise.resolve(a._asyncDataPromises[s]).then(()=>n);return Object.assign(w,n),w}async function ee(e){await new Promise(s=>T(s));const r=e?K(e):void 0;await R().hooks.callHookParallel("app:data:refresh",r)}function J(e,r){r in e.payload.data&&(e.payload.data[r]=void 0),r in e.payload._errors&&(e.payload._errors[r]=m.errorValue),e._asyncData[r]&&(e._asyncData[r].data.value=void 0,e._asyncData[r].error.value=m.errorValue,e._asyncData[r].pending.value=!1,e._asyncData[r].status.value="idle"),r in e._asyncDataPromises&&(e._asyncDataPromises[r]&&(e._asyncDataPromises[r].cancelled=!0),e._asyncDataPromises[r]=void 0)}function Q(e,r){const s={};for(const i of r)s[i]=e[i];return s}function W(e,r,s){const[i={},t]=typeof r=="string"?[{},r]:[r,s],a=L(()=>h(e)),l=i.key||M([t,typeof a.value=="string"?a.value:"",...X(i)]);if(!l||typeof l!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+l);if(!e)throw new Error("[nuxt] [useFetch] request is missing.");const p=l===t?"$f"+l:l;if(!i.baseURL&&typeof a.value=="string"&&a.value[0]==="/"&&a.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:P,lazy:y,default:_,transform:n,pick:v,watch:g,immediate:w,getCachedData:b,deep:c,dedupe:f,...u}=i,o=N({...I,...u,cache:typeof i.cache=="boolean"?void 0:i.cache}),D={server:P,lazy:y,default:_,transform:n,pick:v,immediate:w,getCachedData:b,deep:c,dedupe:f,watch:g===!1?[]:[o,a,...g||[]]};let d;return k(p,()=>{var E;(E=d==null?void 0:d.abort)==null||E.call(d,"Request aborted as another request to the same endpoint was initiated."),d=typeof AbortController<"u"?new AbortController:{};const $=h(i.timeout);let C;return $&&(C=setTimeout(()=>d.abort("Request aborted due to timeout."),$),d.signal.onabort=()=>clearTimeout(C)),(i.$fetch||globalThis.$fetch)(a.value,{signal:d.signal,...o}).finally(()=>{clearTimeout(C)})},D)}function X(e){var s;const r=[((s=h(e.method))==null?void 0:s.toUpperCase())||"GET",h(e.baseURL)];for(const i of[e.params||e.query]){const t=h(i);if(!t)continue;const a={};for(const[l,p]of Object.entries(t))a[h(l)]=h(p);r.push(a)}return r}const ae=(e,r)=>{const s=`${window.location.origin}/api/v1`,i=R().$Fetch;return W(`${s}${e}`,{...r,$fetch:i},"$uf5PLIydgD")};export{ee as r,ae as u};
