import{as as T,at as R,au as m,H as O,K as B,p as F,av as H,O as L,L as U,N as E,aw as j,h as x,ax as z,ay as M,q as N,az as h,aA as S,P as V,aB as K}from"./C5-ExHym.js";function I(e){return Array.isArray(e)?e:[e]}const G=e=>e==="defer"||e===!1;function k(...e){var b;const n=typeof e[e.length-1]=="string"?e.pop():void 0;typeof e[0]!="string"&&e.unshift(n);let[s,i,t={}]=e;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const a=R(),l=i,p=()=>m.value,P=()=>a.isHydrating?a.payload.data[s]:a.static.data[s];t.server=t.server??!0,t.default=t.default??p,t.getCachedData=t.getCachedData??P,t.lazy=t.lazy??!1,t.immediate=t.immediate??!0,t.deep=t.deep??m.deep,t.dedupe=t.dedupe??"cancel";const y=t.getCachedData(s,a),_=y!=null;if(!a._asyncData[s]||!t.immediate){(b=a.payload._errors)[s]??(b[s]=m.errorValue);const c=t.deep?O:B;a._asyncData[s]={data:c(_?y:t.default()),pending:O(!_),error:F(a.payload._errors,s),status:O("idle"),_default:t.default}}const r={...a._asyncData[s]};delete r._default,r.refresh=r.execute=(c={})=>{if(a._asyncDataPromises[s]){if(G(c.dedupe??t.dedupe))return a._asyncDataPromises[s];a._asyncDataPromises[s].cancelled=!0}if(c._initial||a.isHydrating&&c._initial!==!1){const u=c._initial?y:t.getCachedData(s,a);if(u!=null)return Promise.resolve(u)}r.pending.value=!0,r.status.value="pending";const f=new Promise((u,o)=>{try{u(l(a))}catch(D){o(D)}}).then(async u=>{if(f.cancelled)return a._asyncDataPromises[s];let o=u;t.transform&&(o=await t.transform(u)),t.pick&&(o=Q(o,t.pick)),a.payload.data[s]=o,r.data.value=o,r.error.value=m.errorValue,r.status.value="success"}).catch(u=>{if(f.cancelled)return a._asyncDataPromises[s];r.error.value=j(u),r.data.value=x(t.default()),r.status.value="error"}).finally(()=>{f.cancelled||(r.pending.value=!1,delete a._asyncDataPromises[s])});return a._asyncDataPromises[s]=f,a._asyncDataPromises[s]},r.clear=()=>J(a,s);const v=()=>r.refresh({_initial:!0}),g=t.server!==!1&&a.payload.serverRendered;{const c=z();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const o=c._nuxtOnBeforeMountCbs;H(()=>{o.forEach(D=>{D()}),o.splice(0,o.length)}),L(()=>o.splice(0,o.length))}g&&a.isHydrating&&(r.error.value||y!=null)?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):c&&(a.payload.serverRendered&&a.isHydrating||t.lazy)&&t.immediate?c._nuxtOnBeforeMountCbs.push(v):t.immediate&&v();const f=M();if(t.watch){const o=U(t.watch,()=>r.refresh());f&&E(o)}const u=a.hook("app:data:refresh",async o=>{(!o||o.includes(s))&&await r.refresh()});f&&E(u)}const w=Promise.resolve(a._asyncDataPromises[s]).then(()=>r);return Object.assign(w,r),w}async function ee(e){await new Promise(s=>T(s));const n=e?I(e):void 0;await R().hooks.callHookParallel("app:data:refresh",n)}function J(e,n){n in e.payload.data&&(e.payload.data[n]=void 0),n in e.payload._errors&&(e.payload._errors[n]=m.errorValue),e._asyncData[n]&&(e._asyncData[n].data.value=void 0,e._asyncData[n].error.value=m.errorValue,e._asyncData[n].pending.value=!1,e._asyncData[n].status.value="idle"),n in e._asyncDataPromises&&(e._asyncDataPromises[n]&&(e._asyncDataPromises[n].cancelled=!0),e._asyncDataPromises[n]=void 0)}function Q(e,n){const s={};for(const i of n)s[i]=e[i];return s}function W(e,n,s){const[i={},t]=typeof n=="string"?[{},n]:[n,s],a=N(()=>h(e)),l=i.key||S([t,typeof a.value=="string"?a.value:"",...X(i)]);if(!l||typeof l!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+l);if(!e)throw new Error("[nuxt] [useFetch] request is missing.");const p=l===t?"$f"+l:l;if(!i.baseURL&&typeof a.value=="string"&&a.value[0]==="/"&&a.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:P,lazy:y,default:_,transform:r,pick:v,watch:g,immediate:w,getCachedData:b,deep:c,dedupe:f,...u}=i,o=V({...K,...u,cache:typeof i.cache=="boolean"?void 0:i.cache}),D={server:P,lazy:y,default:_,transform:r,pick:v,immediate:w,getCachedData:b,deep:c,dedupe:f,watch:g===!1?[]:[o,a,...g||[]]};let d;return k(p,()=>{var q;(q=d==null?void 0:d.abort)==null||q.call(d,"Request aborted as another request to the same endpoint was initiated."),d=typeof AbortController<"u"?new AbortController:{};const $=h(i.timeout);let C;return $&&(C=setTimeout(()=>d.abort("Request aborted due to timeout."),$),d.signal.onabort=()=>clearTimeout(C)),(i.$fetch||globalThis.$fetch)(a.value,{signal:d.signal,...o}).finally(()=>{clearTimeout(C)})},D)}function X(e){var s;const n=[((s=h(e.method))==null?void 0:s.toUpperCase())||"GET",h(e.baseURL)];for(const i of[e.params||e.query]){const t=h(i);if(!t)continue;const a={};for(const[l,p]of Object.entries(t))a[h(l)]=h(p);n.push(a)}return n}const ae=(e,n)=>{const s=`${window.location.origin}/api/v1`,i=R().$Fetch;return W(`${s}${e}`,{...n,$fetch:i},"$uf5PLIydgD")};export{ee as r,ae as u};
